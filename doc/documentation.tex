\documentclass[12pt, a4paper]{article}
\usepackage{fullpage}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{url}
\usepackage{nameref}
\usepackage{amsmath}

\DeclareTextFontCommand{\code}{\ttfamily}

% ----------------------------------------

\title{Befunge-93 interpreter in Haskell\\
\vspace{5pt}
\small{A project for the course Program Design and Data Structures (1DL201)}}
\author{Staffan Annerwall, Patrik Johansson, Erik Rimskog}

\begin{document}

\maketitle

\begin{abstract}
empty
\end{abstract}

\newpage

\tableofcontents

\newpage

\section{Introduction}
We introduce the programming language Befunge-93 and its fundamental principles.
\label{sec:intro}

\subsection{What is Befunge-93?}
\label{sec:whatis}

Befunge is a two-dimensional esoteric programming language developed by Chris Pressey in 1993 \cite{esolangs}. The program to be executed is stored in a 80 by 25 grid (in this document also referred to as the “program space” or “memory“) where each cell can hold 1 byte of data.

There are no variables available but data can be stored in either a LIFO-stack (last-in-first-out) or -- using the \code{p} instruction -- the program space itself. This allows for the program to modify itself while running.

\subsubsection{Program flow and the Program Counter}
\label{sec:pc}

Program flow is determined by the position and direction of a unique Program Counter (“PC”). The position is usually represented as a pair $(x, y)$ of coordinates and the direction is always one of either East, South, West or North. Traveling East or West increases or decreases the $x$-component of the PC's position respectively, and traveling North or South increases or decreases the $y$-component similarly.

The PC starts at position (0, 0) -- the upper-left corner of the program space -- and has an initial direction of East. Execution of any Befunge program then consists of three simple steps:
\begin{enumerate}

\item Read the character at the PC's position in the program memory.
\item Execute the instruction corresponding to the character that was read, if possible.
\item Step the PC one step in its direction.

\end{enumerate}
These three steps are repeated until an \code{@}-character is read in step 1 at which point the program immediately terminates. See section \ref{sec:instructions} for more information on instructions.

\subsubsection{The stack}
\label{sec:stack}

The stack has the property that it is never truly empty. Instead, if an attempt to pop a value of the stack is made when the stack is thought to be empty, a value of \code{0} is returned. The stack is in all but this one regard a regular LIFO-stack.

\subsubsection{The program space}
\label{sec:space}

The program space consists of 2,000 cells arranged in a 80 by 25 grid. The upper left corner of this grid is given the coordinate position $(0, 0)$ and the lower right corner is identified as $(79, 24)$, see Figure \ref{fig:grid}.

The grid can topologically be thought of as a torus (or a dough-nut); should the PC at any point try to move outside the bounds of the program space, it “wraps around” to the other side. For example, assuming that indexing starts at 0, if the PC is at position (6, 24) and attempts to move South, its new position would be (6, 0), still facing South.

\begin{figure}[!ht]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
$(0, 0)$ & $(1, 0)$ & $\cdots$ & $(79, 0)$\\
\hline
$(0, 1)$ & $(1, 1)$ & $\cdots$ & $(79, 1)$\\
\hline
$\vdots$ & $\vdots$ & $\ddots$ & $\vdots$\\
\hline
$(0, 24)$ & $(1, 24)$ & $\cdots$ & $(79, 24)$\\
\hline
\end{tabular}
\caption{A visualization of the program space in Befunge.}
\label{fig:grid}
\end{figure}

\subsection{Funge-98}
\label{sec:funge98}

Befunge-93 was the first iteration of several Befunge-specifications which eventually lead to Funge-98, a generalization of in which program spaces can be either one-, two-, or three-dimensional. Funge-98 also provides a paradigm for program spaces in an arbitrary number of dimensions \cite{funge98}. Besides new dimensions, Funge-98 also specifies several new instructions as well as concurrent program flow and a stack of stacks.

\section{Running the interpreter}
\label{sec:howtorun}

empty

\subsection{Linux}
\label{sec:runlinux}

empty

\subsection{Windows}
\label{sec:runwindows}

empty

\subsection{Befunge instruction characters}
\label{sec:instructions}

Befunge-93 allows for a total of 35 actions, 9 of which simply push numeric values 0 -- 9.

See Table \ref{tab:instr} for a complete list of all instructions that the interpreter handles. If the PC encounters an unrecognized character (i.e. a character that is not in the table), it ignores it completely -- as if it were a space (\textvisiblespace).

\begin{table}[!hb]
\centering
\begin{tabular}{c|l}
Character & Action\\
\hline
\code{0} -- \code{9} & Push the desired value onto the stack.\\
\code{+} & Pop \code{b} and \code{a} off the stack, then push $\code{a} + \code{b}$.\\
\code{-} & Pop \code{b} and \code{a} off the stack, then push $\code{a} - \code{b}$.\\
\code{*} & Pop \code{b} and \code{a} off the stack, then push $\code{a} \times \code{b}$.\\
\code{/} & Pop \code{b} and \code{a} off the stack, then push $\code{a} / \code{b}$.\\
\code{\%} & Pop \code{b} and \code{a} off the stack, then push $\code{a} \text{ mod } \code{b}$.\\
\code{\`} & Pop \code{b} and \code{a} off the stack. If $\code{a} > \code{b}$ then push \code{1}, otherwise push \code{0}.\\
\code{!} & Pop \code{a} and if \code{a} is non-zero then push \code{0}, otherwise push \code{1}.\\
\code{>} & Instruct the PC to move East.\\
\code{v} & Instruct the PC to move South.\\
\code{<} & Instruct the PC to move West.\\
\code{\^} & Instruct the PC to move North.\\
\code{?} & Instruct the PC to move in a random cardinal direction.\\
\code{\#} & Skip the next instruction; the PC moves twice.\\
\code{\_} & Pop \code{a} and instruct the PC to move West if $\code{a} \neq 0$, otherwise East.\\
\code{|} & Pop \code{a} and instruct the PC to move North if $\code{a} \neq 0$, otherwise South.\\
\code{:} & Duplicate the top value of the stack.\\
\code{\textbackslash} & Swap the top two values of the stack.\\
\code{\$} & Pop a value off the stack and discard it.\\
\code{g} & Pop \code{y} and \code{x}, then push the value of the character at position $(\code{x}, \code{y})$.\\
\code{p} & Pop \code{y}, \code{x} and \code{v}, then insert \code{v} at position $(\code{x}, \code{y})$.\\
\code{\&} & Wait for user value input and push it.\\
\code{\textasciitilde} & Wait for user character input and push its ASCII value.\\
\code{.} & Pop a value and print it, followed by a space (\textvisiblespace).\\
\code{,} & Pop a value and print its ASCII character.\\
\code{\textvisiblespace} & Spaces are ignored, the PC continues and no other modifications are made. \\
\code{@} & Terminate the program.
\end{tabular}
\caption{A list of all Befunge-93 instructions; the interpreter handles all of them correctly.}
\label{tab:instr}
\end{table}

\subsection{Example programs}
\label{sec:examples}

empty

\subsubsection{Basic arithmetic}

Addition (\code{+}), subtraction (\code{-}), multiplication (\code{*}), division (\code{/}) and modulo (\code{\%}) behave as one would expect, with the top-most of the two values popped off the stack acting as the second argument. That is, the program \code{65-.} prints $1$ (and not $-1$). Divison by \code{0} pushes \code{0} back to the stack regardless of the value of the numerator.

An example that utilizes all of these instructions is \code{329*+2*7/4\%.@}. It first pushes \code{3}, \code{2} and \code{9} to the stack followed by a multiplication of the top two values making the stack look like \code{18 3}, where the left-most value is the top of the stack. The \code{+} instruction adds the top two values on the stack; the stack then contains a single value \code{21}. This is then multiplied by \code{2} and divided by \code{7} resulting in the stack \code{6}. Finally, a \code{4} is pushed and the modulo operation \code{\%} calculates $6 \text{ mod } 4 = 2$ and pushes it. \code{2} is printed by \code{.} and the program stops after reading the \code{@}-character.

\subsubsection{Input and output}

empty

\subsubsection{If-statements}

empty

\subsubsection{\code{p}utting and \code{g}etting values}

\section{Implementation}
\label{sec:impl}

In which we discuss how the interpreter is implemented, including the data structures and algorithms used.

\subsection{Data structures}
\label{sec:structures}

empty

\subsubsection{Stack}
\label{sec:structstack}

The Befunge stack, defined in \code{BStack.hs}, is implemented using a list of integers. It exports one identifier (\code{empty}) and three functions (\code{push}, \code{pop}, \code{top}). The type \code{BStack} is defined as a list of integers: \code{newtype BStack = BStack [Int] deriving (Show)}. The identifier \code{empty} (of type \code{BStack}) is identified simply as \code{BStack [\hspace{2pt}]}.

\vspace{6pt}
\noindent
\code{push} (\code{BStack -> Int -> Bstack}) takes a (possibly empty) stack \code{s} and an integer \code{n}, and returns \code{s} with \code{n} on top.

\vspace{6pt}
\noindent
\code{pop} (\code{BStack -> (BStack, Int)}) takes a stack \code{s} and returns a tuple \code{(s', t)} where \code{t} is the top element of \code{s} and \code{s'} is \code{s} with \code{t} removed. Should \code{s} be empty, a tuple \code{(BStack [\hspace{2pt}], 0)} is returned.

\vspace{6pt}
\noindent
\code{top} (\code{BStack -> Int}) takes a stack and returns its top element without modifying the stack.

\vspace{6pt}
\noindent
All three functions have precondition \code{True}.

\subsubsection{Program space}
\label{sec:structmem}

The Befunge program space, the “memory”, is constructed using an array. \code{BMemory.hs} is a wrapper for an \code{IOArray} (from \code{Data.Array.IO}) and the type \code{BMemory} is synonymous to \code{IOArray Position Char}. It exports three functions:

\vspace{6pt}
\noindent
\code{buildArray} (\code{BMemory -> [String] -> IO ()}) allocates an array and populates it with the characters in a list of strings. Any characters outside the bounds (defaults to 80$\times$25) are ignored.

\vspace{6pt}
\noindent
\code{getValue} (\code{BMemory -> Position -> IO Char}) takes an array and returns the character at the given position.

\vspace{6pt}
\noindent
\code{putValue} (\code{BMemory -> Position -> Char -> IO ()}) takes an array, a position and a value. It inserts the value at the given position and returns nothing.

\vspace{6pt}
\noindent
Both \code{getValue} and \code{putValue} wraps array indices using modulus.

\subsection{Algorithms}
\label{sec:algorithms}

empty

\subsection{Major functions}
\label{sec:functions}

empty (remember specifications!)

\subsubsection{Program flow}
\label{sec:flow}

also empty

\section{Shortcomings and caveats}

\vfill

\bibliographystyle{ieeetr}
\bibliography{documentation}

\end{document}